Някои от обичайните проблеми при разработката на софтуер:

* Вие се разполагането на вашите приложения ръчно, това е болка в областта на шията, и това отнема много време.
* Интеграцията на сорс кода се извършва ръчно и конфликти се появят често.
* Вие приложение за редактиране на конфигурацията ръчно в пунктове за спиране и производствени среди.
* Кодът "работи на моята машина" и е проблем в тяхната код.
* Нямате автоматизирани тестове.
* Често се налага да поправяте нещо в последния момент.

Непрекъснатата интеграция е практика за разработване на софтуер, където всеки  член на екипа интегрира своята работа периодично, обикновено всеки човек го прави поне веднъж дневно, което води до множество интеграции на ден. Всяка интеграция се подлага на автоматичен билд (включително  и на тестове) за откриване на грешки възможно най-скоро. В много случаи тази практика води до значително намаляване на интеграционните проблеми и позволява екипа да разработи даден софтуер по-бързо и ефективно.


Честото билдване и тестване на софтуера води до много ползи. Този процес, познат като continuous integration, позволява на разработчиците да откриват и поправят проблеми в своите приложения в момента на възникването им, вместо да бъдат затрупани с множество бъгове за поправяне, когато дойде момента за пускане на готовия продукт (product release).Ако интеервалът от време между последния успешен билд на приложението и новооткрития проблем е малък, е по-лесно да бъдат открити именно модификациите в кода, които са довели до това, че кодът не се компилира или не отговаря на тестовете. Важно е такива проблеми да се поправят възможно най-рано в процеса на разработване, за да не води той до други такива впоследствие, когато друга функционалност на приложението бъде надградена върху съществуващата. Една евентуална поправка на бъга, ако бъде направена след по-дълго време (например ако тестовете не се пускаха при всеки билд и той не бъде открит скоро), би струвала много повече време и усилия, понеже с голяма вероятност ще се наложи и промяна в други части от кода, писани по-късно.






Непрекъсната интеграция (CI) е практиката в софтуерното инженерство на периодично сливане на всички разработки по кода с обща основна линия, най-често веднъж или по няколко пъти на ден. За първи път е предложена като част от Екстремното програмиране (ЕП). Нейната основна цел е да предотврати интеграционни проблеми, реферирани като "интеграционен ад" в ранните описания на ЕП. Непрекъснатата интеграция  може да се разглежда като на засилване на практиките за осъществяване на периодичен интеграция, предложени по-рано от техниките за инкрементална и итеративна разработка на софтуер, като например метода на Буч. 
Непрекъснатата интеграция първоначално е била с идеята да бъде прилагана в комбинация от автоматични юнит тестове, създавани чрез практиката на разработване чрез тестове (test-driven-developlent). По-точно считало се е,  че всички тестове ще бъдат пускани преди сливането с общата линия (mainline) и това сливане ще се осъществява само ако резултатите от тестовете са положителни. По-късно е въведено използването на билд-сървър, който автоматично пуска юнит-тестовете периодично, а също и при всеки commit и докладва резултатите на разработчиците
Системите за Continuous integration и автоматизирано билдване и тестване се използват в много софтуерни продукти. Ползите от тези системи най-често се обсъждат в дискусии за гъвкавите методологии за разработване на софтуер (Agile software development). Има различни платени и свободни (open source). Почти всички те осигуряват базовата функционалност за билдване и изпълнение на тестове,  като някои от най-използваните са Tinderbox на Mozilla Corporation, Maven на Apache Software Foundation, CruiseControl, Bamboo и др. 


Когато трябва да извърши някаква промяна в кода, например когато трябва да създаде нова функционалност или да измени имплементацията на съществуваща такава, разработчикът създава локално копие на текущия код, по което да работи. Понеже останалите разработчици променят други части от кода в основната линия, това локално копие малко по малко престава да отразява действителния код в хранилището. Не само вече съществуващият код бива променен, но и могат да бъдат добавяни нови библиотеки и други ресурси, които съзават зависимости и потенциални конфликти. Колкото по-дълго дадено разклонение на кода остане несъгласувано с кода в хранилището, толкова по-голям е шансът за множество интеграционни конфликти и грешки, когато той бъде интегриран в главната линия. Когато разработчиците предават своя код в хранилището, те първо трябва да обновят локално своя код, така че напълно да отразява последно направените промени в хранилището, откакто те са създали своето локално копие. Колкото повече промени съдържа хранилището, толково повече работа имат разработчиците преди да предадат своите собствени промени. Евентуално, хранилището може да е толкова да се е променило, че разработчикът да изпадне в т.нар. „ад на сливането” или „интеграционен ад”, където времето, което отнема  самата интеграция многократно надвишава времето, което са отнели съответните промени в кода. В най-лошия случай на разработчикът може да се наложи да отхвърли своите локални промени и да започне работа отначало.
Продължителната интеграция препоръчва интеграцията да става възможно най-често и рано, за да бъдат избягвани проблеми като този с „итеграционния ад”.По този начин се цели да се избегне излишната работа и така да се спестят време и ресурси. Например, всеки програмист трябва да започне деня с обновяване на локалното копие на хранилището, като по-този начин остава максимално съгласуван с него.

Принципи:
както вече споменахме, интегрирането на промените в кода с вече съществуващия трябва да се случва достатъчно успешно, за да няма проблемно забавяне между предаването на кода (commit) и билда, като по този начин няма как да възникнат грешки без разработчиците да ги забележат и да ти отстранят незабавно. Нормалната практика е да се извършва билд при всеки commit към хванилището, вместо да се извършва периодичен билд (например на няколко часа, или всяка вечер). Друг фактор за успешното прилагане на непрекъснатата интеграция е наличието на version-control system, или система за контрол на версиите. Тя трябва да поддържа атомарна операция по предаване (commit), т.е. всички промени в даден commit да се разглеждат като единична промяна. Няма логика в това да бъдат приети само половината от променените файлове, например. И така, за да се постигнат тези цели, продължителната интеграция разчита ан следните принципи:
* Поддържане на хранилище (repository)
* Автоматизиране на билда
* С билда автоматично да се пускат тестове
* Всеки разработчик  предава локалните си промени всеки ден
* Всеки commit към основната линия трябва да бъде build-нат
* Билдът трябва да е бърз
* Тестването става в копие на реалната среда
* Резултатите трябва да са ясни веднага
* Всички да могат да виждат резултата от последния билд
* Автоматично обновяване (automate deployment)

Поддържане на хранилище (repository)
Според този принцип, наложителна е употребата на система за контрол на версиите за кода на софтуерния продукт. На центално място трябва да се пази актуалното състояние на кода и във всеки момент този код трябва да е в състояние, в което е преминал билда и тестовете. Препоръчително е разклоняването на кода в отделни клонове да се минимизира и по възможност да се избягва напълно. Вместо това всички промени да бъдат интегрирани към една единствена обща линия, за да не се налага няколко версии на софтуера да бъдат поддържани едновременно, което би изисквало повече усилия, време и внимание. Главната линия трябва във всеки момент да съдържа последната работеща версия на софтуера.
Автоматизиране на билда
Билд-ването на системата трябва да става с една единствена команда. Иначе казано, при нейното изпълнение да се извършва не само компилиране на изпълнимите кодове, но и да се генерира актуална документация, анализ за покритието на кода, статистики по изпълнението и др.
С билда автоматично да се пускат тестове
Веднага щом билдът на кода прикючи, всички тестове се пускат, за да се потвърди, че кодът се държи така, както разработчиците очакват от него.
Всеки разработчик  предава локалните си промени всеки ден
Чрез редовното commit-ване, всеки разработчик може да намали броя на проблемните промени. Ако например това става само веднъж седмично, вероятността новите промени да са в конфликт с друга функционалност, разработена по същото време от друг член на екипа, е голяма, а дори е възможна появата на конфликт, който на практика няма как да бъде разрешен. От друга страна малките ранни конфликти са далеч по-лесни за разрешаване. Затова и предаването на промените поне веднъж дневно (и непременно веднъж при всяка логическа промяна в кода) са задължителни и се считат за част от дефиницията на непрекъснатата интеграция. Като допълнение, пускането на т.нар. нощен билд е препоръчително. Това са минималните изисквания, като всъщност честотата на интегрирането се очаква да бъде поне няколко commit-а дневно.
Всеки commit към основната линия трябва да бъде build-нат
Системата трябва да build-ва всички промени по текущата работеща версия, за да гарантира, че се интегрират правилно. Честа практика е да се използва автоматизирана непрестанна интеграция, въпреки че това може да се прави ръчно. За мнозина непрекъсната интеграция всъщност е синоним на автоматичната непрекъсната интеграция, където системен процес (daemon) следи системата за контрол на кода за промени и при отчитането на такива автоматично стартира процеса по build-ване.
Билдът трябва да е бърз
Билдът трябва да завършва бързо, за да може ако има проблем с интеграцията, да бъде открит бързо. За целта понякога се налага например само избрана част от тестовете да се пускат -  онези, които проверяват функционалност, която е засегната от промените.
Тестването става в копие на реалната среда
Наличието на отделна среда за тестове може да доведе до грешки в тествания продукт, когато бъде пуснат в реална среда, понеже тестовата среда значително може да се различава от реалната по някакъв начин. Затова тестовата среда трябва да симулира максимално реалната, като разбира се бъде някаква по-малка нейна версия, за да може да се намалят разходите по поддръжката и др.
Резултатите трябва да са ясни веднага
Когато резултатите от билда веднага пристигат до разработчиците и  тестърите, се намалява процентът на излишната работа в случаите, когато дадена промяна в кода не покрива изискванията (чупи билда). Допълнително, ранното тестване намалява шансовете дефектите да достигнат до фазата на пускане на готовия продукт. Откриването на грешки в ранна фаза.
Всички да могат да виждат резултата от последния билд

Трябва лесно да може да се разбере дали билда е счупен и ако да, кой е направил промените, довели до това.
Автоматично обновяване (automate deployment)
Повечето системи за непрекъсната интеграция позволяват пускането на скриптове, след като билдът приключи. В повечето случаи в възможно да се напише скрипт, който да ‘качи’ обновения софтуер на сървър със свободен достъп. Следващата стъпка в тази посока е т.нар. continuous deployment. При него новата версия софтуерът веднага се пуска за ползване и всеки потребител може да обнови своята локална версия ръчно или автоматично. Разбира се, при това е нужно допълнително подсигуряване за възможни регресии в софтуера, което да предотврати евентуални проблеми, свързани с несъответствие във версиите и такива, възникнали вследствие промяната на кода. 
Advantages
* Непрекъснатата интеграция има следните големи предимства:
* Когато юнит тест не мине или когато бъг се появи, разработчиците могат да върнат кода в предишно стабилно състояние без да се налага да извършват т.нар дебъгване – търсене и отстраняване на бъга (което часто отнема време).
* Разработчиците засичат и отстраняват проблеми с интеграцията постоянно – избягвайки хаоса в дните непосредствено преди пускането на готовия продукт (когато всеки предава своята част от кода и се оказва, че версиите са несъвместими)
* Ранно предупреждение за счупен или несъвместим код
* Ранно предупреждение за конфликтни промени
* Незабавно юнит тестване на всички промени
* Постоянна наличност на ‘текуща’ версия за тестване, демо или релийз
* Незабавна обратна връзка към разработчиците за качеството, функционалността и цялостното влияние върху системата на кода, който създават
* Честите commit-и стимулират разработването на модулярен и по-прост код
* Анализа на покритието на кода (code coverage), сложността и функционалността му, фокусират разработчиците върху създаването на функционален и качествен код
Maintain a Single Source Repository

Софтуерните проекти включват множество файлове, които трябва да бъдат съгласувани, за да се получи готов продукт. Надзора и боравенето с всички тях изиска големи усилия, особено когато много хора са замесени. Затова и не е изненадващо, че през годините екипите за разработка на софтуер са създали инструменти, които да им помагат да се справят с това. Тези инструменти – наречени програми за управление на кода, мениджъри на конфигурацията, системи за контрол на кода, хранилища (repositories) или с различни други имена – са неделима част от повечето проекти. Изненадващо е, че не са част от всички проекти. Рядкост е, но все още има такива при които все още се борави с различни комбинации на локални и споделени дискове, но това са случаи предимно в малки фирми и по незначителни проекти, като неизбежно скоро този вариант ще бъде тотално забравен, поради недотам добрата си ефективност.
В хранилището трябва да се добавя всичко необходимо за билда: тестови скриптове, файлове с настройки, схема на баззата данни, скриптове за инсталиране, допълнителни библиотеки и др. Основното правило е на ‘чиста’ локална машина само с минимален набор неща  да може да се build-не целия проект. В това влизат разбира се софтуер, който е сложен за инсталиране и задължително стабилен – типични примери са операционна система, среда за разработка на съответния програмен език (IDE), система за управление на бази данни и пр. 
Освен всичко необходимо за билд, в хранилището могат да се добавят и допълнителни файлове, с които останалите от екипа ще работят. Например файл с настойки и конфигурации на IDE-то, за да може всички да споделят едни и същи настройки, като така се избягват нежелани проблеми.
Една от характеристиките на системите за управление на версиите е, че позволяват създаването на множество клонове (branches), за обработка на отделните насоки в проекта. Това е полезна възможност, но всъщност се използва повече от необходимото и често създава проблеми с последващата синхронизация на клоновете. Затова се препоръчва свеждане употребата на различни клонове до минимум. Вместо това е добре да се ползва единствен клон, наречен основна линия (mainline) – където във всеки момент да стои текущо работещият код, по който се работи и с който всички да се съгласуват. Всеки разработчик трябва да се работи именно с този код и да приобщава промените си към него. Все пак понякога се налага временното създаване не отделни клонове, като добри примери за разумни такива са поправка на бъгове, предишни релийз-и на кода, временни експерименти и др.
Automate the Build

Превръщането на изходния код в работеща система често може да се окаже сложен процес, включващ компилация, местене на файлове, зареждане на схеми в бази данни и пр. Така или иначе, както редица други задачи при софтуерната разработка, и това може да бъде автоматизирано и следователно – трябва да бъде автоматизирано. Да караш хората да пишат странни команди или всеки път да избират едни и също опции от даден потребителски диалог е загуба на време, а също така и предпоставка за допускане на предотвратими човешки грешки.
Исторически погледнато, разработчиците са използвали автоматизацията на билда за да пуснат в изпълнение компилатора и свързващия редактор (linker) от даден скрипт, вместо да се налага да го правят през командната конзола. Лесно е да се използва конзолата за да се подаде единичен модул с код на компилатора и тогава на линкъра,  за да създаде готовия обект. Но когато се налага да се компилират и свързат десетки стотици, а понякога и хиляди модули, и то в определена последователност, използването на командната конзола не е подходящо решение. Първи пробив в това отношение прави скриптовият език make, който позволява даден скрипт да бъде написан така, че да извиква правилните команди към интерпретатора и свързващия редактор в подходяща последователност. GNU Make също предлага допълнителни възможности, като например "makedepend" което позволява да се въведат някакви зависимости от сорс кода, а също и възможност за инкрементално билдване. Казаното дотук е за зората на автоматизацията на билда. Тогава фокусът е бил върху автоматизирането на командите към компилатора и линкъра. Но с развитието на процеса по билдване, разработчиците започнали да добавят предварителни и последващи действия, освен тези,, като например копирането от хранилището в тестовата среда на необходимите за тестовете обекти. Терминът автоматизация на билда днес включва като действията преди компилиране и свързване, така и самите тях, а също и последващите ги действия – анализ на кода, на функционалността, ефективността му и др.
Автоматизираните среди за билдване от години са част от системите. В Unix те съществуват от десетилетия, Java общостта е изградила Ant, а в .NET има MSBuild. Коя да е от споменатите позволява билдването и стартирането на необходимите скриптове с използването само на еднократна команда.
Често допускана грешка е да не се включва всичко в автоматизирания билд. Той трябва например да вземе схемата база данни от хранилището и да я зареди в изпълнимата среда. И отново ще припомним споменато вече неписано правило: всеки трябва да може да на ‘чиста’ машина, след като се съгласува с хранилището, да изпълни единствена команда и да има работещата система на своя компютър. 
Скриптовете за билда са доста различни ни често са специфично за отделната платформа, но не би трябвало да бъдат. Въпреки че повечето Java проекти използват Ant, някои ползват и Ruby, чиято скриптова система Rake е доста добър и функционален инструмент.
Големият билд често отнема време, а никой не иска да извършва всички тези стъпки ако е направил само една малка промяна в кода. Затова добрият инструмент билдване като част от процеса анализира какво трябва да бъде променено. Най-честият начин да бъде направено това е да се свери датата на сорса и обектните файлове и да се компилира само кодът, който е с по-късна дата. И тогава зависимостите стават сложни: ако даден обектен файл променя този, от който зависи, вторият също може да се нуждае от повторе билд. Компилаторите може да успеят да се справят с тези неща, а може би не. 
В зависимост от нуждите, различни неща може да се наложи да бъдат билд-нати. Системата може да бъде билдната с или без кода с тестовете, или с различни набори от тестове. Някои компоненти могат да се билднат самостоятелно. Скриптът е онова, което позволява желаната опция да бъде избрана алтернативно в различните случаи. 
Много
Many of us use IDEs, and most IDEs have some kind of build management process within them. However these files are always proprietary to the IDE and often fragile. Furthermore they need the IDE to work. It's okay for IDE users set up their own project files and use them for individual development. However it's essential to have a master build that is usable on a server and runnable from other scripts. So on a Java project we're okay with having developers build in their IDE, but the master build uses Ant to ensure it can be run on the development server.











 

